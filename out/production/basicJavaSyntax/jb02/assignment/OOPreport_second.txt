객체 지향 프로그래밍 (OOP: Object-Oriented Programming)
객체 지향 프로그래밍은 프로그래밍에 필요한 속성(attribute)과 메서드(method)를 가진 클래스를 정의하고, 이 클래스를 통해 각각의 객체(object)를 생성하여, 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 기존의 절차지향 프로그래밍은 정해진 입력을 받아 정해진 순서대로 처리하는 방식이었다. 기술이 발전함에 따라 복잡한 프로그래밍이 필요하게 되면서 구조적 프로그래밍이 탄생하였고, 데이터 구조화의 한계를 극복하기 위해 객체 지향 프로그래밍이 발전하게 되었다.

객체(Object)
객체는 객체 지향 프로그래밍의 가장 기본적인 단위로, 보고 느끼고 인지하는 모든 것, 즉 모든 실재하는 대상을 뜻한다. 객체는 클래스에서 정의한 것을 토대로 실제 메모리에 할당되어 프로그램에서 사용된다. 객체는 고유의 속성과 행동을 가지며, 다른 객체와의 상호작용을 통해 프로그램의 전체적인 기능을 수행한다.

클래스(Class)
클래스는 원하는 구조의 객체를 만들기 위한 설계 도구이다. 동일한 속성과 기능을 가진 여러 객체를 만들어야 할 경우, 클래스는 이들을 정의하는 틀을 제공한다. 클래스는 객체의 속성과 행동을 정의하며, 이 클래스에서 생성된 객체를 인스턴스(instance)라고 부른다. 만약 여러 객체가 동일한 속성을 가지도록 구현해야 한다면, 모든 객체의 속성을 개별적으로 수정해야 하는 번거로움이 있을 것이다. 클래스는 이러한 문제를 해결하여, 속성과 메서드를 클래스에서 정의하고 필요에 따라 수정할 수 있도록 한다.

추상화(Abstraction)
추상화는 객체 지향의 네 가지 핵심 특징 중 하나로, 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다. 추상화를 통해 불필요한 세부사항을 숨기고, 객체의 본질적인 부분만을 나타낸다. 자바에서 추상화를 구현할 수 있는 문법 요소로는 추상 클래스와 인터페이스가 있다. 인터페이스는 객체가 수행해야 하는 핵심적인 역할만을 규정하며, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들이 담당한다. 이를 통해 코드는 더 유연해지고, 다양한 구현체들 사이에서 일관된 방법으로 동작할 수 있다.

일반화(Generalization) / 상속(Inheritance)
일반화는 객체 지향 프로그래밍에서 공통된 속성과 동작을 상위 클래스로 추출하여 정의하는 과정이다. 이를 통해 중복된 코드를 줄이고, 코드의 재사용성을 높일 수 있다. 일반화는 다양한 객체들이 공유할 수 있는 기본적인 특성을 정의함으로써, 코드의 일관성을 높이고 유지보수를 쉽게 만든다.

상속은 상위 클래스의 속성과 기능을 하위 클래스가 물려받아 사용할 수 있도록 하는 것을 의미한다. 이를 통해 하위 클래스는 상위 클래스의 속성과 메서드를 그대로 사용할 수 있으며, 필요에 따라 추가적인 기능을 덧붙일 수 있다. 상속은 코드의 재사용성을 높이고, 시스템의 구조를 더 체계적으로 만들어 준다.

특수화(Specialization)
특수화는 일반화의 반대 개념으로, 상위 클래스의 속성과 기능을 더 구체적이고 상세하게 구현하는 하위 클래스를 만드는 과정이다. 이를 통해 하위 클래스는 상위 클래스의 일반적인 특성을 물려받으면서도, 자신만의 고유한 속성과 메서드를 추가로 정의할 수 있다. 예를 들어, '동물'이라는 상위 클래스가 있다면, '고양이', '강아지'와 같은 하위 클래스가 특수화된 클래스로 존재할 수 있다. 이들은 '동물'의 일반적인 특징을 공유하면서도 각자 고유한 행동과 특성을 가질 수 있다.

실현(Realization)
실현은 객체 지향 설계에서 인터페이스를 실제로 구현하는 과정을 의미한다. 인터페이스는 클래스가 어떤 메서드를 가져야 하는지를 정의하는 추상적 개념으로, 그 자체로는 동작하지 않지만, 특정 클래스가 이 인터페이스를 실현하여 구체적인 구현체를 제공한다. 예를 들어, '날아다닐 수 있는'이라는 인터페이스를 구현하는 클래스는 여러 가지가 있을 수 있으며, 각 클래스는 해당 인터페이스에 정의된 메서드를 자신의 방식대로 구현한다. 이를 통해 시스템은 동일한 인터페이스를 사용하는 객체들 간의 일관성을 유지하면서도, 각 객체의 특수한 동작을 허용할 수 있다.

연관(Association)
연관은 두 개 이상의 클래스가 서로 관계를 맺고 있는 것을 나타낸다. 이는 객체 간의 물리적 또는 개념적 연결을 설명하며, 다중도(multiplicity)에 따라 1:1, 1:다, 다:다의 형태를 가질 수 있다. 예를 들어, '교수'와 '학생' 간의 관계를 생각해 볼 수 있다. 한 명의 교수는 여러 학생을 가르칠 수 있으며, 한 학생은 여러 교수의 수업을 들을 수 있다. 이러한 관계를 표현하는 것이 연관이다.

의존(Dependency)
의존은 한 클래스가 다른 클래스의 변화에 영향을 받는 관계를 의미한다. 이는 주로 메서드의 매개변수로 다른 클래스의 객체를 사용하는 경우에 발생하며, 한 클래스의 변화가 다른 클래스의 동작에 영향을 미칠 수 있는 것을 뜻한다. 예를 들어, '자동차' 클래스가 '엔진' 클래스를 사용하는 경우, 엔진의 설계가 변경되면 자동차 클래스에도 변경이 필요할 수 있다. 이러한 의존 관계는 시스템의 복잡성을 증가시키므로, 의존성을 줄이기 위한 다양한 설계 패턴이 존재한다.

다형성(Polymorphism)
다형성은 동일한 메시지에 대해 서로 다른 방법으로 응답할 수 있는 객체의 능력을 의미한다. 이는 주로 상속과 인터페이스를 통해 구현되며, 프로그램이 더 유연하고 확장 가능하도록 만든다. 예를 들어, '동물'이라는 상위 클래스에 '소리내기'라는 메서드가 있다면, '고양이'와 '강아지'는 각각 '야옹'과 '멍멍'으로 다른 방식으로 이 메서드를 구현할 수 있다. 이로 인해, 프로그램은 상위 클래스 타입의 객체를 통해 다양한 하위 클래스의 동작을 실행할 수 있다.

캡슐화(Encapsulation) / 절차 은닉 / 정보 은닉
캡슐화는 객체 지향 프로그래밍에서 객체의 데이터(속성)와 이를 처리하는 메서드를 하나의 단위로 묶어 외부로부터 보호하는 것을 의미한다. 이를 통해 객체의 내부 구현을 감추고, 객체의 상태를 안전하게 유지할 수 있다. 캡슐화는 객체의 복잡성을 줄이고, 코드의 유지보수성을 높이는 데 중요한 역할을 한다.

정보 은닉은 캡슐화의 한 측면으로, 객체의 내부 상태와 구현 세부 사항을 외부에 숨기는 것을 뜻한다. 외부에서는 객체가 제공하는 인터페이스를 통해서만 객체와 상호작용할 수 있으며, 객체의 내부 구현이 변경되더라도 외부에 미치는 영향이 최소화된다. 정보 은닉은 객체의 무결성을 보장하고, 잘못된 사용으로부터 객체를 보호한다. 이를 통해 객체 간의 결합도가 낮아지고, 시스템의 복잡성이 줄어든다.

절차 은닉은 객체 내부에서 특정 작업을 수행하는 방법을 외부에 드러내지 않는 것을 의미한다. 이는 객체가 제공하는 기능의 구현 방법을 외부로부터 숨기고, 외부에서는 객체가 제공하는 메서드의 인터페이스만 사용하도록 유도한다. 절차 은닉을 통해 코드의 재사용성을 높이고, 객체의 기능이 변경되더라도 외부에 영향을 미치지 않도록 설계할 수 있다.