객체 지향 프로그래밍 (OOP: Object-Oriented Programming)
객체 지향 프로그래밍은 프로그래밍에 필요한 속성(attribute)과 메서드(method)를 가진 클래스를 정의하고, 이 클래스를 통해 각각의 객체(object)를 생성하여 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 기존의 절차지향 프로그래밍은 정해진 입력을 받아 정해진 순서대로 처리하는 방식이었다. 기술이 발전함에 따라 복잡한 프로그래밍이 필요하게 되면서 구조적 프로그래밍이 탄생하였고, 데이터 구조화의 한계를 극복하기 위해 객체 지향 프로그래밍이 발전하게 되었다. 객체 지향 프로그래밍은 코드의 재사용성과 확장성을 향상시켜, 대규모 소프트웨어 개발에 적합한 방법론으로 자리 잡았다.

객체(Object)
객체는 객체 지향 프로그래밍의 가장 기본적인 단위로, 보고 느끼고 인지하는 모든 것, 즉 모든 실재하는 대상을 뜻한다. 객체는 클래스에서 정의한 것을 토대로 실제 메모리에 할당되어 프로그램에서 사용된다. 객체는 고유의 속성과 행동을 가지며, 다른 객체와의 상호작용을 통해 프로그램의 전체적인 기능을 수행한다. 예를 들어, 자동차 시뮬레이션 프로그램에서 '자동차' 객체는 속도, 색상 등의 속성을 가지며, 가속, 감속 등의 행동을 수행할 수 있다. 이러한 객체는 서로 메시지를 주고받으며, 프로그램의 흐름을 제어하고 다양한 기능을 수행한다.

클래스(Class)
클래스는 원하는 구조의 객체를 만들기 위한 설계 도구이다. 동일한 속성과 기능을 가진 여러 객체를 만들어야 할 경우, 클래스는 이들을 정의하는 틀을 제공한다. 클래스는 객체의 속성과 행동을 정의하며, 이 클래스에서 생성된 객체를 인스턴스(instance)라고 부른다. 만약 여러 객체가 동일한 속성을 가지도록 구현해야 한다면, 모든 객체의 속성을 개별적으로 수정해야 하는 번거로움이 있을 것이다. 클래스는 이러한 문제를 해결하여, 속성과 메서드를 클래스에서 정의하고 필요에 따라 수정할 수 있도록 한다. 이는 코드의 중복을 줄이고, 유지보수를 용이하게 만들어 준다.

예를 들어, '학생'이라는 클래스를 정의하고, 이 클래스는 이름, 학번, 성적 등의 속성을 가질 수 있다. 또한, 성적을 조회하거나 업데이트하는 메서드를 포함할 수 있다. 이 클래스를 기반으로 여러 '학생' 객체를 생성할 수 있으며, 각각의 객체는 고유한 데이터를 가진다.

추상화(Abstraction)
추상화는 객체 지향의 네 가지 핵심 특징 중 하나로, 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다. 추상화를 통해 불필요한 세부사항을 숨기고, 객체의 본질적인 부분만을 나타낸다. 자바에서 추상화를 구현할 수 있는 문법 요소로는 추상 클래스와 인터페이스가 있다. 인터페이스는 객체가 수행해야 하는 핵심적인 역할만을 규정하며, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들이 담당한다. 이를 통해 코드는 더 유연해지고, 다양한 구현체들 사이에서 일관된 방법으로 동작할 수 있다.

추상화는 복잡한 시스템을 단순화하고, 이해하기 쉽게 만드는 데 기여한다. 예를 들어, '운송 수단'이라는 추상 클래스는 이동, 정지 등의 메서드를 정의할 수 있다. 각기 다른 이동 수단, 예를 들어 자동차나 자전거는 이러한 메서드를 구체적으로 구현하여 각자의 방식대로 동작할 수 있다.

일반화(Generalization) / 상속(Inheritance)
일반화는 객체 지향 프로그래밍에서 공통된 속성과 동작을 상위 클래스로 추출하여 정의하는 과정이다. 이를 통해 중복된 코드를 줄이고, 코드의 재사용성을 높일 수 있다. 일반화는 다양한 객체들이 공유할 수 있는 기본적인 특성을 정의함으로써, 코드의 일관성을 높이고 유지보수를 쉽게 만든다.

상속은 상위 클래스의 속성과 기능을 하위 클래스가 물려받아 사용할 수 있도록 하는 것을 의미한다. 이를 통해 하위 클래스는 상위 클래스의 속성과 메서드를 그대로 사용할 수 있으며, 필요에 따라 추가적인 기능을 덧붙일 수 있다. 상속은 코드의 재사용성을 높이고, 시스템의 구조를 더 체계적으로 만들어 준다. 예를 들어, '동물'이라는 상위 클래스가 있다면, '고양이', '강아지'와 같은 하위 클래스가 있을 수 있다. 이들은 '동물'의 일반적인 속성과 행동을 물려받으면서도, 각자의 고유한 특성과 행동을 추가할 수 있다.

특수화(Specialization)
특수화는 일반화의 반대 개념으로, 상위 클래스의 속성과 기능을 더 구체적이고 상세하게 구현하는 하위 클래스를 만드는 과정이다. 이를 통해 하위 클래스는 상위 클래스의 일반적인 특성을 물려받으면서도, 자신만의 고유한 속성과 메서드를 추가로 정의할 수 있다. 예를 들어, '동물'이라는 상위 클래스가 있다면, '고양이', '강아지'와 같은 하위 클래스가 특수화된 클래스로 존재할 수 있다. 이들은 '동물'의 일반적인 특징을 공유하면서도 각자 고유한 행동과 특성을 가질 수 있다.

특수화는 객체 지향 프로그래밍에서 코드의 구체성과 명확성을 높인다. 특정 객체가 구체적인 작업을 수행하거나 특수한 행동을 필요로 할 때, 특수화는 이를 쉽게 구현할 수 있는 방법을 제공한다.

실현(Realization)
실현은 객체 지향 설계에서 인터페이스를 실제로 구현하는 과정을 의미한다. 인터페이스는 클래스가 어떤 메서드를 가져야 하는지를 정의하는 추상적 개념으로, 그 자체로는 동작하지 않지만, 특정 클래스가 이 인터페이스를 실현하여 구체적인 구현체를 제공한다. 예를 들어, '날아다닐 수 있는'이라는 인터페이스를 구현하는 클래스는 여러 가지가 있을 수 있으며, 각 클래스는 해당 인터페이스에 정의된 메서드를 자신의 방식대로 구현한다. 이를 통해 시스템은 동일한 인터페이스를 사용하는 객체들 간의 일관성을 유지하면서도, 각 객체의 특수한 동작을 허용할 수 있다.

실현은 다양한 객체들이 공통된 인터페이스를 통해 상호작용할 수 있게 만들어 준다. 이는 특히 대규모 시스템에서 모듈 간의 결합도를 낮추고, 시스템을 더 유연하고 확장 가능하게 만든다.

연관(Association)
연관은 두 개 이상의 클래스가 서로 관계를 맺고 있는 것을 나타낸다. 이는 객체 간의 물리적 또는 개념적 연결을 설명하며, 다중도(multiplicity)에 따라 1:1, 1:다, 다:다의 형태를 가질 수 있다. 예를 들어, '교수'와 '학생' 간의 관계를 생각해 볼 수 있다. 한 명의 교수는 여러 학생을 가르칠 수 있으며, 한 학생은 여러 교수의 수업을 들을 수 있다. 이러한 관계를 표현하는 것이 연관이다.

연관은 객체 지향 설계에서 시스템의 구조를 설명하고, 객체 간의 관계를 명확히 하는 중요한 개념이다. 연관 관계는 시스템 내에서 객체들이 어떻게 상호작용하는지를 이해하는 데 도움을 준다.

의존(Dependency)
의존은 한 클래스가 다른 클래스의 변화에 영향을 받는 관계를 의미한다. 이는 주로 메서드의 매개변수로 다른 클래스의 객체를 사용하는 경우에 발생하며, 한 클래스의 변화가 다른 클래스의 동작에 영향을 미칠 수 있는 것을 뜻한다. 예를 들어, '자동차' 클래스가 '엔진' 클래스를 사용하는 경우, 엔진의 설계가 변경되면 자동차 클래스에도 변경이 필요할 수 있다. 이러한 의존 관계는 시스템의 복잡성을 증가시키므로, 의존성을 줄이기 위한 다양한 설계 패턴이 존재한다.

의존 관계는 시스템의 복잡성과 유지보수에 직접적인 영향을 미친다. 따라서, 객체 간의 의존성을 최소화하고 모듈화하는 것은 객체 지향 설계의 중요한 목표 중 하나이다.

다형성(Polymorphism)
다형성은 동일한 메시지에 대해 서로 다른 방법으로 응답할 수 있는 객체의 능력을 의미한다. 이는 주로 상속과 인터페이스를 통해 구현되며, 프로그램을 더 유연하고 확장 가능하도록 만든다. 예를 들어, '동물'이라는 상위 클래스에 '소리내기'라는 메서드가 있다면, '고양이'와 '강아지'는 각각 '야옹'과 '멍멍'으로 이 메서드를 다르게 구현할 수 있다. 이를 통해 프로그램은 상위 클래스 타입의 객체를 통해 다양한 하위 클래스의 동작을 실행할 수 있다.

다형성은 특히 다양한 객체들이 공통된 인터페이스를 통해 상호작용할 때 유용하다. 이를 통해 클라이언트 코드는 특정 객체의 실제 타입에 관계없이 일관된 방식으로 객체를 사용할 수 있다. 예를 들어, 다양한 형태의 도형 객체들이 공통의 '그리기' 메서드를 구현하고 있다면, 클라이언트 코드는 도형 객체의 타입에 관계없이 동일한 방법으로 이 메서드를 호출할 수 있다.

캡슐화(Encapsulation)
캡슐화는 객체 지향 프로그래밍에서 객체의 데이터(속성)와 이를 처리하는 메서드를 하나의 단위로 묶어 외부로부터 보호하는 것을 의미한다. 이를 통해 객체의 내부 구현을 감추고, 객체의 상태를 안전하게 유지할 수 있다. 캡슐화는 객체의 복잡성을 줄이고, 코드의 유지보수성을 높이는 데 중요한 역할을 한다.

캡슐화는 객체의 내부 상태를 외부에서 직접 접근하지 못하도록 하고, 외부에서는 객체가 제공하는 공용 인터페이스를 통해서만 상호작용할 수 있도록 한다. 이로 인해 객체의 구현 세부 사항이 외부에 노출되지 않으며, 객체의 상태와 동작이 보다 안전하게 보호된다.

정보 은닉(Information Hiding)
정보 은닉은 캡슐화의 한 측면으로, 객체의 내부 상태와 구현 세부 사항을 외부에 숨기는 것을 의미한다. 외부에서는 객체가 제공하는 인터페이스를 통해서만 객체와 상호작용할 수 있으며, 객체의 내부 구현이 변경되더라도 외부에 미치는 영향이 최소화된다. 정보 은닉은 객체의 무결성을 보장하고, 잘못된 사용으로부터 객체를 보호한다. 이를 통해 객체 간의 결합도가 낮아지고, 시스템의 복잡성이 줄어든다.

정보 은닉을 통해 객체는 내부의 상태를 안전하게 유지하면서도, 필요한 기능을 외부에 제공할 수 있다. 이는 유지보수와 확장성을 높이는 데 기여하며, 시스템의 안정성을 향상시킨다.

절차 은닉(Procedural Hiding)
절차 은닉은 객체 내부에서 특정 작업을 수행하는 방법을 외부에 드러내지 않는 것을 의미한다. 이는 객체가 제공하는 기능의 구현 방법을 외부로부터 숨기고, 외부에서는 객체가 제공하는 메서드의 인터페이스만 사용하도록 유도한다. 절차 은닉을 통해 코드의 재사용성을 높이고, 객체의 기능이 변경되더라도 외부에 영향을 미치지 않도록 설계할 수 있다.

절차 은닉은 객체의 기능을 외부와 독립적으로 유지할 수 있도록 하여, 객체 내부의 구현이 변경되어도 외부에 미치는 영향을 최소화한다. 이는 소프트웨어의 유지보수성과 모듈성을 높이는 데 중요한 역할을 한다.