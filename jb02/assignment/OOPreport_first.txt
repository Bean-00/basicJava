OOP(Object Oriented Programming)
프로그래밍에 필요한 attribute와 method를 가진 class를 정의하고, 정의된 클래스를 통해 각각의 object를 생성하여, 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. 기존 정해진 입력을 받아, 정해진 순서대로 처리하는 절차지향 프로그래밍에서 기술이 발전함에 따라 복잡한 프로그래밍 작성이 필요하게 되어 구조적 프로그래밍이 탄생하였고 해당 구조적 프로그래밍의 데이터 구조화의 한계를 해결하기 위해 객체지향 프로그래밍이 탄생하게 되었다.

Object
객체 지향 프로그래밍의 가장 기본적인 단위로, 보고 느끼고 인지하는 그 모든 것, 즉 모든 실재하는 대상을 뜻한다. 이때 Object는 클래스에서 정의한 것을 토대로 실제 메모리에 할당되어 실제 프로그램에서 사용되는 데이터로 사용되어진다.

Class
원하는 구조의 Object 툴을 짜놓고, 비슷한 모양의 Object를 만들어낼 수 있는 것을 말한다. 여러 동일한 속성의 Object들을 만들고 이에 대해 동일한 기능을 추가해야 한다면 만들었던 모든 Object의 속성을 모두 수정해야할 것이다. 또한 원하는 동일한 속성을 만드는 중, 오타가 발생하여 오류가 발생할 수 있고 특정 속성을 기입하지 않아 원치 않은 결과가 나올 수 있다. 이를 Class로 동일한 속성을 가진 Object를 만들고 만든 Class의 속성을 수정하는 것으로 이를 한 번에 해결하는 것이 가능하다. 이때 Class로 생성된 Object를 Instance라고 한다.

Abstraction(추상화)
객체 지향의 4가지 특징 중 하나로 객체의 공통적인 속성과 기능을 추출하여 정의하는 것을 의미한다. 자바에서 Abstraction을 구현할 수 있는 문법 요소로는 추상 클래스와 인터페이스가 있다. 인터페이스에는 추상 메서드나 상수를 통해서 어떤 객체가 수행해야하는 핵심적인 역할만을 규정해두고, 실제적인 구현은 해당 인터페이스를 구현하는 각각의 객체들에서 하도록 프로그램을 설계하게 된다.

Generalization(일반화) / Inheritance(상속)
일반화는 객체 지향 프로그래밍에서 공통된 속성과 동작을 상위 클래스로 추출하여 정의하는 과정이다. 이를 통해 중복된 코드를 줄이고, 코드의 재 사용성을 높일 수 있다.
상속은상위 Class로부터 확장된 여러 개의 하위 Class들이 모두 상위 Class의 속성과 기능을 가지는 것을 뜻한다. 반적으로 동일한 속성을 작성할 필요 없이 상위 Class에서 상속 받아 사용할 수 있게 된다. 이를 통해 코드의 재사용성이 높아지고, 반복적인 코드의 불필요한 작성을 줄일 수 있게 된다.

Specialization(특수화)
특수화는 일반화의 반대 개념으로, 상위 클래스의 속성과 기능을 더 구체적이고 상세하게 구현하는 하위 클래스를 만드는 과정입니다. 이를 통해 하위 클래스는 상위 클래스의 일반적인 특성을 물려받으면서도, 자신만의 고유한 속성과 메서드를 추가로 정의할 수 있습니다. 예를 들어, '동물'이라는 상위 클래스가 있다면, '고양이', '강아지'와 같은 하위 클래스가 특수화된 클래스로 존재할 수 있습니다. 이들은 '동물'의 일반적인 특징을 공유하면서도 각자 고유한 행동과 특성을 가질 수 있습니다.

Realization
실현은 객체 지향 설계에서 인터페이스를 실제로 구현하는 과정을 의미합니다. 인터페이스는 클래스가 어떤 메서드를 가져야 하는지를 정의하는 추상적 개념으로, 그 자체로는 동작하지 않지만, 특정 클래스가 이 인터페이스를 '실현'하여 구체적인 구현체를 제공합니다. 예를 들어, '날아다닐 수 있는' 이라는 인터페이스를 구현하는 클래스는 여러 가지가 있을 수 있으며, 각 클래스는 해당 인터페이스에 정의된 메서드를 자신의 방식대로 구현합니다. 이를 통해 시스템은 동일한 인터페이스를 사용하는 객체들 간의 일관성을 유지하면서도, 각 객체의 특수한 동작을 허용할 수 있습니다.

Association
연관은 두 개 이상의 클래스가 서로 관계를 맺고 있는 것을 나타냅니다. 이는 객체 간의 물리적 또는 개념적 연결을 설명하며, 다중도(multiplicity)에 따라 1:1, 1:다, 다:다의 형태를 가질 수 있습니다. 예를 들어, '교수'와 '학생' 간의 관계를 생각해 볼 수 있습니다. 한 명의 교수는 여러 학생을 가르칠 수 있으며, 한 학생은 여러 교수의 수업을 들을 수 있습니다. 이러한 관계를 표현하는 것이 연관입니다.

Dependency
의존은 한 클래스가 다른 클래스의 변화에 영향을 받는 관계를 의미합니다. 이는 주로 메서드의 매개변수로 다른 클래스의 객체를 사용하는 경우에 발생하며, 한 클래스의 변화가 다른 클래스의 동작에 영향을 미칠 수 있는 것을 뜻합니다. 예를 들어, '자동차' 클래스가 '엔진' 클래스를 사용하는 경우, 엔진의 설계가 변경되면 자동차 클래스에도 변경이 필요할 수 있습니다. 이러한 의존 관계는 시스템의 복잡성을 증가시키므로, 의존성을 줄이기 위한 다양한 설계 패턴이 존재합니다.

Polymorphism
다형성은 동일한 메시지에 대해 서로 다른 방법으로 응답할 수 있는 객체의 능력을 의미합니다. 이는 주로 상속과 인터페이스를 통해 구현되며, 프로그램이 더 유연하고 확장 가능하도록 만듭니다. 예를 들어, '동물'이라는 상위 클래스에 '소리내기'라는 메서드가 있다면, '고양이'와 '강아지'는 각각 '야옹'과 '멍멍'으로 다른 방식으로 이 메서드를 구현할 수 있습니다. 이로 인해, 프로그램은 상위 클래스 타입의 객체를 통해 다양한 하위 클래스의 동작을 실행할 수 있습니다.

Encapsulation(캡슐화) / 절차 은닉 / 정보 은닉
캡슐화는 객체 지향 프로그래밍에서 객체의 데이터(속성)와 이를 처리하는 메서드를 하나의 단위로 묶어 외부로부터 보호하는 것을 의미합니다. 이를 통해 객체의 내부 구현을 감추고, 객체의 상태를 안전하게 유지할 수 있습니다. 캡슐화는 객체의 복잡성을 줄이고, 코드의 유지보수성을 높이는 데 중요한 역할을 합니다.

정보 은닉
정보 은닉은 캡슐화의 한 측면으로, 객체의 내부 상태와 구현 세부 사항을 외부에 숨기는 것을 뜻합니다. 외부에서는 객체가 제공하는 인터페이스를 통해서만 객체와 상호작용할 수 있으며, 객체의 내부 구현이 변경되더라도 외부에 미치는 영향이 최소화됩니다. 정보 은닉은 객체의 무결성을 보장하고, 잘못된 사용으로부터 객체를 보호합니다. 이를 통해 객체 간의 결합도가 낮아지고, 시스템의 복잡성이 줄어듭니다.

절차 은닉
절차 은닉은 객체 내부에서 특정 작업을 수행하는 방법을 외부에 드러내지 않는 것을 의미합니다. 이는 객체가 제공하는 기능의 구현 방법을 외부로부터 숨기고, 외부에서는 객체가 제공하는 메서드의 인터페이스만 사용하도록 유도합니다. 절차 은닉을 통해 코드의 재사용성을 높이고, 객체의 기능이 변경되더라도 외부에 영향을 미치지 않도록 설계할 수 있습니다.